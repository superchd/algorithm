# Greedy

> ### 문제 풀이 방법::
>> * 딕셔너리로 문제의 인풋값들을 받는다. 왜냐하면, key 값을 기준으로 정렬을 해야하는데, 딕셔너리가 적당한 자료형이라 생각했는데, 다시보면 그냥 튜플이나 리스트로 정렬을 충분히
>> 할수 있어서 그리 좋은 선택은 아니였던것 같다. 덕분에 key값을 중복으로 받지 않는 딕셔너리의 특징 때문에 불가피하게 클래스를 정의했다.    

```python 
class number(object):
    def __init__(self,num):
        self.num = num
```
>> * 다음과 같은 방법으로는 key값 중복이여도 딕셔너리에 추가할 수 있는 기술이다. 
>> * 그후에 key값과 value값 따로 리스트를 만들어서, 테이블을 채워 넣었다. 
>> * 헷갈렸던 점은 원래 딕셔너리내의 원소의 개수대로 반복문을 반복한 후, 테이블에 원소를 넣으면 삭제하는 방식으로 했는데, 이러다보니 각 원소를 가르키는 인덱스 값이 달라져서  
>> * 1번째 원소작업을 하면 2번째 원소작업을 해야하는데 바로 3번째 원소로 작업하는 경우로 넘어가기도 했다. 그래서 어떻게 할까 하다가 while문으로 작업을 했다.
>> * while문으로 작업을 하고, 인덱스 기반으로 원소를 지정하는게 아니라, 마치 큐처럼 첫번째 원소가 테이블에 들어갈 수 있나 아닌가 판단하고, 괜찮은 경우 리스트에서 삭제를 해주는
>> 방법이 괜찮았던것 같다.

> ### 배운 점::
>> * 원소를 삭제하는 경우에는 인덱스 기반으로 접근하지말고, 큐나 스택을 이용하자.
>> * 딕셔너리를 sort한 결과는 또 딕셔너리가 아니고 튜플의 리스트이다. 따라서 , 또 딕셔너리를 만드려면 zip 메써드를 사용해야한다. 

> ### 아직은 2번째 최대 수익을 내는 경우를 못찾아서 .....
